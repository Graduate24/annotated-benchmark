# Java语义还原研究计划

## 项目概述

本项目旨在研究如何使用大型语言模型（LLM）对带有框架特性（如注解、依赖注入等）的Java代码进行语义还原，将其转换为纯Java代码，使静态分析工具能够更准确地分析安全漏洞。

## 语义还原的核心理念

语义还原不是指完全等价地实现注解或框架的功能，而是在静态分析层面，通过简化、抽象、补全等手段，使得代码语义基本一致，确保静态分析工具的能力不受限。主要遵循以下原则：

1. **保证从无到有，适当简化**：填补框架自动完成的代码，但不需要复杂实现
2. **保持静态分析重要路径**：确保数据流和控制流不因简化而丢失
3. **重点关注安全漏洞分析相关的代码**：优先还原可能影响安全分析结果的部分

## 还原重点

### 依赖注入（DI）还原
- 将`@Autowired`注解的字段通过`new`关键字进行初始化
- 为被注入类的构造函数添加必要的参数
- 处理循环依赖的特殊情况

### 配置值注入还原
- 将`@Value`注解引用的配置直接赋值给对应字段
- 处理表达式（如`${property}`）和默认值
- 支持多种配置源（YAML、Properties）

### AOP（面向切面编程）还原
- 识别切面和通知（Advice）
- 在目标方法中插入对应的通知代码
- 处理不同类型的通知（前置、后置、环绕等）

### MyBatis等ORM框架还原
- 为`@Mapper`接口生成简单实现类
- 提供基本SQL查询实现
- 保留查询中可能存在的漏洞点

## 技术方案

### 建模分析
1. 使用静态分析工具提取项目结构和元数据
2. 识别框架特性（注解、依赖关系等）
3. 生成项目建模报告（JSON格式）

### 语义还原
1. 基于建模报告识别需要还原的组件
2. 利用大模型（如GPT-4）生成等效的纯Java代码
3. 处理特殊情况和异常

### 代码生成与验证
1. 生成可编译的Java代码
2. 验证还原代码的静态分析结果
3. 比较原始代码和还原代码的安全漏洞检测效果

## 评估指标

1. **代码完整性**：还原代码是否可以成功编译
2. **语义保真度**：原始代码与还原代码的静态分析结果一致性
3. **漏洞检测率**：还原前后对已知漏洞的检测成功率对比
4. **性能效率**：还原过程的时间和资源消耗

## 项目结构

```
semantic-restoration/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── modeling/           # 代码建模相关
│   │   │   ├── restoration/        # 语义还原核心
│   │   │   ├── llm/                # LLM接口和提示词
│   │   │   └── utils/              # 工具类
│   │   └── resources/
│   └── test/
├── data/
│   ├── models/                     # 建模结果
│   └── restored/                   # 还原结果
├── docs/                           # 文档
└── scripts/                        # 辅助脚本
```

## 研究计划里程碑

1. **阶段一：建模工具开发**
   - 实现Java项目结构分析
   - 实现框架特性识别（注解、依赖关系）
   - 生成标准化建模报告

2. **阶段二：LLM还原引擎设计**
   - 设计还原策略和算法
   - 实现LLM接口和提示词模板
   - 开发代码生成与验证框架

3. **阶段三：评估与优化**
   - 对典型项目进行还原测试
   - 评估还原效果
   - 优化还原策略和算法

4. **阶段四：拓展与应用**
   - 支持更多Java框架和库
   - 与静态分析工具集成
   - 开发自动化工作流